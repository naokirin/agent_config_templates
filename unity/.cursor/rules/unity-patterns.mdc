---
description: Unity architecture and performance patterns
globs: "Assets/**/*.cs"
alwaysApply: false
---

# Unity Patterns

## Architecture Patterns

### Observer Pattern
Decouple systems using events. Prefer `System.Action` or UnityEvents for inspector-configurable callbacks.

```csharp
// Event channel as ScriptableObject
[CreateAssetMenu]
public class GameEvent : ScriptableObject
{
    private readonly List<Action> _listeners = new();
    public void Raise() => _listeners.ForEach(l => l?.Invoke());
    public void Register(Action listener) => _listeners.Add(listener);
    public void Unregister(Action listener) => _listeners.Remove(listener);
}
```

Reference: https://learn.unity.com/tutorial/create-modular-and-maintainable-code-with-the-observer-pattern

### State Pattern
Use for AI, game states, UI flows. Encapsulate state-specific behavior in state classes.

```csharp
public interface IState { void Enter(); void Execute(); void Exit(); }
public class StateMachine
{
    private IState _currentState;
    public void ChangeState(IState newState)
    {
        _currentState?.Exit();
        _currentState = newState;
        _currentState?.Enter();
    }
    public void Update() => _currentState?.Execute();
}
```

Reference: https://learn.unity.com/tutorial/develop-a-modular-flexible-codebase-with-the-state-programming-pattern-1

### MVC/MVP
Separate UI from game logic. Model holds data, View handles display, Controller/Presenter mediates.

Reference: https://learn.unity.com/tutorial/build-a-modular-codebase-with-mvc-and-mvp-programming-patterns-1

## Performance Patterns

### Object Pooling
Reuse objects instead of instantiate/destroy. Essential for bullets, particles, enemies.

```csharp
public class ObjectPool<T> where T : Component
{
    private readonly Queue<T> _pool = new();
    private readonly T _prefab;
    public T Get() => _pool.Count > 0 ? _pool.Dequeue() : Object.Instantiate(_prefab);
    public void Return(T obj) { obj.gameObject.SetActive(false); _pool.Enqueue(obj); }
}
```

Reference: https://learn.unity.com/tutorial/use-object-pooling-to-boost-performance-of-c-scripts-in-unity

### Performance Tips
- Cache GetComponent results
- Avoid allocations in Update (use object pooling, StringBuilder)
- Use Jobs and Burst for CPU-intensive work
- Profile with Unity Profiler before optimizing

Reference: https://docs.unity3d.com/Manual/best-practice-guides.html

## Project Structure

### Version Control
- Use .gitignore for Library/, Temp/, Logs/, obj/
- Consider Git LFS for large binary assets
- Use Plastic SCM or Git with Unity Smart Merge

Reference: https://unity.com/how-to/version-control-systems

### DevOps
- Use task branch workflow for features
- Automate builds with Unity Build Server or CI/CD

Reference: https://unity.com/how-to/devops-task-branch-workflow
